<h1>Core Characteristics</h1>

<section class="normative">
    <h2>Method Name</h2>

    <p>
        The method name that identifies this DID method SHALL be: <code>webs</code>.
    </p>
    <blockquote>
        Note: when pronounced aloud, "webs" SHOULD become two syllables: the word "web" and
        the letter "s" (which stands for "secure"). Separating the final letter this way
        emphasizes that the method offers a security upgrade analogous to the one that HTTPS
        gives to HTTP.
    </blockquote>
    <p>
        A DID that uses this method MUST begin with the following prefix: <code>did:webs:</code>.
        Per the DID specification, this string MUST be in lowercase. The remainder of the DID,
        after the prefix, is the <dfn>method-specific identifier</dfn> (<dfn>MSI</dfn>) described
        <a href="#method-specific-identifier">below</a>.
    </p>
</section>

<section class="normative">
    <h2>Target System(s)</h2>

    <p>
        As with <code>did:web</code>, this method reads data from whatever web server is referenced
        when the (host+)domain portion of one of its DIDs is resolved through the Domain Name System (DNS).
    </p>
    <p>
        However, this method introduces an important nuance about the target system. In many DID
        methods, this system is a verifiable data registry &mdash; besides publishing data,
        its security attributes make that data trustworthy. In this DID method, the target system's
        role is more limited. It is expected to serve data about the DID, and to follow acknowledged
        cybersecurity best practices to preserve good hygiene. However, the integrity of the data is
        guaranteed by the DID value itself, typically in conjunction with a digitally signed key event
        log (KEL).
    </p>
    <p>
        These trust mechanisms &mdash; the integrity checks built into the DID value, and the workings of
        the KEL &mdash; are defined by KERI. KERI is a complex technology, far too rich to explain in
        this DID method. However, the subset of KERI features needed for most <code>did:webs</code> use
        cases is quite small, with limited dependencies, and is summarized in Appendix A. The rest of
        this spec will assume a working knowledge of the concepts there.
    </p>
    <p>
        A target system cannot forge or tamper with data protected by KERI, and if it serves an outdated copy,
        the attempt to be duplicitous is often detectable. Thus, any given target system in isolation
        can be viewed by this method as a dumb, untrusted server of content. It is the combination
        of target systems and a few KERI mechanisms, <em>together</em>, that constitutes this method's
        verifiable data registry.
    </p>
</section>

<section class="normative">
    <h2>Method-Specific Identifier</h2>
    <p>
        There are two forms of method-specific identifier (MSI) for <code>did:webs</code>. One is
        resolvable; the other is autonomic. The resolvable form is more common and intuitive.
    </p>
    <h3>Resolvable Form</h3>
    <p>
        The resolvable form is constructed by transforming an input called the DID doc URL (DDURL).
        This is an HTTPS URL that references a DID doc (either directly, or ultimately, via redirects).
        This transformation must be reversible, because resolving the DID requires clients to fetch
        DID docs from the associated DDURL.
    </p>
    <p>
        The DDURL MUST NOT include a query string (although it could redirect to a URL
        that contains one). The DDURL MUST NOT include relative path components ("./" or "../").
        The DDURL MUST NOT include multiple consecutive slashes. The DDURL MUST NOT include
        a fragment OR redirect to a URL that includes a fragment. It MUST return a resource
        that the web server identifies in headers as IANA media type<code>application/json</code>.
        The DDURL and its corresponding X509 certificate(s) have some security requirements
        described<a href="#security-considerations">elsewhere</a>.
    </p>
    <p>
        The "https://" prefix on this URL is removed. If the path portion of the URL
        consists exactly of "/.well-known/did.json", this suffix is deleted. If the URL
        ends in a slash, the final slash is removed. All remaining slashes in the URL
        are replaced with colons. If the URL ends with ".json", this suffix is deleted.
        If the URL includes a port, the colon that delimits the port number MUST be
        percent-encoded so colons in the MSI map only to slashes.
    </p>
    <p>TODO: what about intl chars? Does DID spec allow them like URL spec does?
    What about localhost vs. 127.0.0.1 vs. ::1?</p>
    <pre class="example" title="sample DDURL &rarr; MSI &rarr; DID transformations">
        https://example.com/a/b.json &rarr; example.com:a:b &rarr; did:webs:example.com:a:b
        https://192.168.1.55:8080/a/b &rarr; 192.168.1.55%3A8080:a:b &rarr; did:webs:192.168.1.55%3A8080:a:b
    </pre>
    <h3>Autonomic Form</h3>
    <p>
        Although URLs are wonderfully useful, they are also notoriously unstable. A DID defined
        by a URL can disappear (or acquire an entirely new value with identical keys) due to
        URL revisions outside the scope of control of the DID owner -- and the DID owner might not
        even be aware. A DID URL can be reused, including by hackers. In addition, the same
        content can be hosted at more than one URL (due to redirects, CDNs, load balancers, NAT,
        IPv4 vs. IPv6, symbolic links, /etc/hosts files, intranet DNS overrides, or just redundant
        publication). This can create interpretation challenges for DIDs based on URLs.
    </p>
    <p>
        To avoid ambiguity, the <code>did:webs</code> method adds an additional form of MSI.
        This is a special CESR-encoded string datatype that KERI calls an AID (autonomic
        identifier). An AID uniquely and stably identifies a DID and its DID doc, regardless
        of where the DID doc is hosted. It is stored in the top-level <code>id</code> property
        of its associated DID doc. A typical AID value looks like this:
    </p>
    <p>
        Internally, AIDs don't carry information about how they can be resolved. They are thus
        very similar to URNs (although they have additional cryptographic properties). An AID
        can be used to build a did:webs value: Therefore,
        an doesn't typically show up in the DID value, but it is examined by systems that
        process the DID. Across all time, all did:webs DID docs that have the same AID are
        describing the same DID, and must be cryptographically consistent with one another. On the other hand, DID docs with different AIDs intend to
        describe different DIDs, even if they are accessed via the same URL (e.g., at different
        times). This makes accidental or deliberate collisions clear, clarifies when different
        DIDs are valid synonyms, and makes internal processing deterministic and independent of
        hosted context.
    </p>
    <p>
        The AID for a given did:webs is stored in the top-level <code>id</code> property of
        its DID doc. All external references to a did:webs are tbuilt on web-oriented URLs, but
        internal processing uses the internal identifier.
    </p>
</section>

<section class="normative">
    <h2>Resolution Process</h2>
    <p>
        Before a <code>did:webs</code> value can be resolved, it must be converted back to a DDURL.
        This is done by replacing the "did:webs:" prefix with https://", converting a percent-
        encoded port delimiter back to a colon, and replacing all other colons with slashes.
        In addition, if the DID includes no path, then "/.well-known/did.json" is appended.
    </p>
    <p>
        An HTTP GET is now performed on the DDURL to fetch a DID doc. This operation MUST follow
        both temporary and permanent redirects, but MUST break redirect cycles and MUST NOT allow
        excessive redirects. The final URL once all redirects have been followed is called the end URL.
        If GETting the end URL returns HTTP status code 404, if the end url contains a path, and if
        the end url does not end in ".json", then a client MUST append ".json" to the end URL and
        make a second attempt to GET the resource with the revised URL.
    </p>
    <p>
        Unlike <code>did:web</code>, the resolution process is not assumed to produce valid
        output simply because a DID doc is returned. The top-level <code>id</code> property
        in the doc contains a KERI AID rather than the value of the DID itself. DID doc is analyzed, and If the DID is a A second GET MUST also be performed. This one
        fetches the KEL. The URL
        for the KEL is generated as follows:
    </p>
    <ol>
        <li>Start with the final URL that successfully fetched a DID doc after all redirects were followed.</li>
        <li>If this URL ends with ".json", change it to end with ".kel.json". Otherwise, just append ".kel".</li>
    </ol>
    <p>
        When a DID is converted back into a DDURL for resolution to a DID doc,

</section>

