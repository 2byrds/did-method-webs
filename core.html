<h1>Core Characteristics</h1>

<section class="normative">
    <h2>Method Name</h2>

    <p>
        The method name that identifies this DID method SHALL be: <code>webs</code>.
    </p>
    <blockquote>
        Note: when pronounced aloud, "webs" SHOULD become two syllables: the word "web" and
        the letter "s" (which stands for "secure"). Separating the final letter this way
        emphasizes that the method offers a security upgrade analogous to the one HTTPS
        gives to HTTP.
    </blockquote>
    <p>
        A DID that uses this method MUST begin with the following prefix: <code>did:webs:</code>.
        Per the DID specification, this string MUST be lower-case. The remainder of the DID,
        after the prefix, is the case-sensitive <dfn>method-specific identifier</dfn>
        (<dfn>MSI</dfn>) described <a href="#method-specific-identifier">below</a>.
    </p>
</section>

<section class="normative">
    <h2>Target System(s)</h2>

    <p>
        As with <code>did:web</code>, this method reads data from whatever web server is referenced
        when the (host+)domain portion of one of its DIDs is resolved through the Domain Name System
        (DNS).
    </p>
    <p>
        However, this method introduces an important nuance about the target system. In many DID
        methods, the target system equals a <dfn>verifiable data registry</dfn> &mdash; besides
        publishing data, its security attributes make that data trustworthy. In this DID method, the
        target system's role is more limited. It is expected to serve data about the DID, and to follow
        acknowledged cybersecurity best practices to preserve good hygiene. However, the authenticity of
        data is guaranteed by the DID value itself, typically in conjunction with a digitally signed
        JSON data structure called a <a>key event log</a> (<a>KEL</a>).
    </p>
    <p>
        These trust mechanisms &mdash; the integrity checks built into the DID value, and the workings of
        the KEL &mdash; are defined by <a>KERI</a>. KERI is a complex technology, far too rich to explain here.
        However, the subset of KERI features needed for most <code>did:webs</code> use cases is modest,
        with limited dependencies. These basics are summarized in <a href="#keri-fundamentals">KERI
        Fundamentals</a>. The rest of this spec assumes a working knowledge of the concepts there.
    </p>
    <p>
        A target system cannot forge or tamper with data protected by KERI, and if it deliberately serves
        an outdated copy, the duplicity is often detectable. Thus, any given target system in isolation
        can be viewed by this method as a dumb, untrusted server of content. It is the combination
        of target systems and a few KERI mechanisms, <em>together</em>, that constitutes this method's
        verifiable data registry.
    </p>
</section>

<section class="normative">
    <h2>Method-Specific Identifier</h2>
    <p>
        There are two forms of <dfn>method-specific identifier</dfn> (<dfn>MSI</dfn>) for
        <code>did:webs</code>. One is <em>resolvable</em>; the other is <em>stable</em>.
        The resolvable form is more common and intuitive.
    </p>
    <h3>Resolvable Form</h3>
    <p>
        A <dfn>resolvable</dfn> MSI is constructed by transforming an input called the <dfn>DID doc URL</dfn>
        (<dfn>DDURL</dfn>). This MUST be an HTTPS URL that references a DID doc (either directly, or ultimately,
        via redirects). The transformation to MSI must be reversible back to DDURL, because resolving the DID
        requires clients to fetch DID docs from the MSI.
    </p>
    <p>
        The DDURL MUST NOT include a query string (although it could redirect to a URL
        that contains one). The DDURL MUST NOT include relative path components ("./" or "../").
        The DDURL MUST NOT include multiple consecutive slashes once the path portion begins.
        The DDURL MUST NOT include a fragment OR redirect to a URL that includes a fragment.
        It MUST return a resource that the web server identifies in headers as IANA media type
        <code>application/json</code>. The DDURL and its corresponding X509 certificate(s) also
        have some security requirements described<a href="#security-considerations">elsewhere</a>.
    </p>
    <p>
        The transformation begins by removing the "https://" prefix from this URL. If the path portion
        of the URL consists exactly of "/.well-known/did.json", this suffix is also removed. If the URL
        ends in a slash, the final slash is removed. All remaining slashes in the URL
        are replaced with colons. If the URL ends with ".json", this suffix is deleted.
        If the URL includes a port, the colon that delimits the port number MUST be
        percent-encoded so colons in the MSI map only to slashes.
    </p>
    <p>TODO: what about intl chars? Does DID spec allow them like URL spec does?
    What about localhost vs. 127.0.0.1 vs. ::1?</p>
    <pre class="example" title="sample DDURL &rarr; MSI &rarr; DID transformations">
        https://example.com/a/b.json &rarr; example.com:a:b &rarr; did:webs:example.com:a:b
        https://192.168.1.55:8080/a/b &rarr; 192.168.1.55%3A8080:a:b &rarr; did:webs:192.168.1.55%3A8080:a:b
    </pre>
    <h3>Stable Form</h3>
    <p>
        Although URLs are wonderfully useful, they are also notoriously unstable. A DID defined
        by a URL can disappear (or acquire an entirely new value with identical keys) due to
        URL revisions outside the scope of control of the DID owner -- and the DID owner might not
        even be aware. A DID URL can be reused, including by hackers. In addition, the same
        content can be hosted at more than one URL (due to redirects, CDNs, load balancers, NAT,
        IPv4 vs. IPv6, symbolic links, /etc/hosts files, intranet DNS overrides, or just redundant
        publication). This can create interpretation challenges for DIDs based on URLs.
    </p>
    <p>
        To avoid ambiguity, the <code>did:webs</code> method adds an additional form of MSI.
        This is a special <a>CESR</a>-encoded string datatype that KERI calls an <a>AID</a> (
        <a>autonomic identifier</a>). An AID uniquely and stably identifies a DID and its DID
        doc, regardless of where the DID doc is hosted. The DID doc for any <code>did:webs</code>
        DID MUST store the stable form of the MSI in its top-level <code>id</code> property.
    </p>
    <p>
        In stable form, <code>did:webs</code> MSIs are simply the AID, with no further information.
        Combining such an MSI with the prefix produces a <dfn>stable DID</dfn> that look like this:
    </p>
    <pre class="example" title="sample AID &rarr; DID transformation">
        EmkPreYpZfFk66jpf3uFv7vklXKhzBrAqjsKAn2EDIPM &rarr; did:webs:EmkPreYpZfFk66jpf3uFv7vklXKhzBrAqjsKAn2EDIPM
    </pre>
    <p>
        Stable DIDs don't carry information about how they can be resolved. They are thus
        very similar to URNs, and have limited utility for a party who has never resolved them
        before. However, they can be resolved if the controller of the DID passes resolution
        material directly to the resolver (see <a href="#resolution-process">Resolution
        Process</a>). Systems that process <code>did:webs</code> MAY also store them as a
        placeholder, to be resolved later. Since the AIDs in stable DIDs lack any dependence
        on web technologies for resolution and discovery, they form the basis of a potential
        interoperability strategy with a DID method that works over other protocols.
    </p>
    <p>
        Across all time, all <code>did:webs</code> DID docs that are identified by the same AID (or
        stable DID) MUST be understood to characterize the same DID, and implementations of this
        method MUST require them to be logically consistent with one another. On the other hand,
        DID docs identified by different AIDs MUST be understood to characterize different DIDs,
        even if they are accessed via the same URL (e.g., at different times). This makes accidental
        or deliberate collisions into errors. Implementations MUST treat them as such
        (e.g., alerting the user that the non-stable form of the DID is ambiguous). It also
        creates the possibility to publish the same DID in different places; the non-stable forms
        of each DID are just synonyms. Internal processing of DID docs (which uses only the stable
        form) is deterministic and independent of context that a DID owner may not control.
    </p>
</section>

<section class="normative">
    <h2>Resolution Process</h2>
    <p>
        Before a <code>did:webs</code> DID can undergo standard resolution, it must be converted
        back to a DDURL. This is done by replacing the "did:webs:" prefix with https://", converting
        a percent-encoded port delimiter back to a colon, and replacing all other colons with slashes.
        In addition, if the DID includes no path, then "/.well-known/did.json" is appended.
    </p>
    <p>
        An HTTP GET is now performed on the DDURL to fetch a DID doc. This operation MUST follow
        both temporary and permanent redirects, but MUST break redirect cycles and MUST NOT allow
        excessive redirects. The final URL once all redirects have been followed is called the
        <dfn>terminal URL</dfn>. If GETting the terminal URL returns HTTP status code 404, if the
        terminal url contains a path, and if the terminal url does not end in ".json", then a client
        MUST append ".json" to the terminal URL and make a second attempt to GET the resource with
        the revised URL.
    </p>
    <p>
        Unlike <code>did:web</code>, the resolution process is not assumed to produce valid
        output simply because a DID doc is returned. The top-level <code>id</code> property
        in the doc contains a KERI AID rather than the value of the DID itself. DID doc is analyzed, and If the DID is a A second GET MUST also be performed. This one
        fetches the KEL. The URL
        for the KEL is generated as follows:
    </p>
    <ol>
        <li>Start with the final URL that successfully fetched a DID doc after all redirects were followed.</li>
        <li>If this URL ends with ".json", change it to end with ".kel.json". Otherwise, just append ".kel".</li>
    </ol>
    <p>
        When a DID is converted back into a DDURL for resolution to a DID doc,

</section>

